// ----------------------------------------------------------------------------
// <auto-generated>
// This is autogenerated code by CppSharp.
// Do not edit this file or all your changes will be lost after re-generation.
// </auto-generated>
// ----------------------------------------------------------------------------
using System;
using System.Runtime.InteropServices;
using System.Security;
using __CallingConvention = global::System.Runtime.InteropServices.CallingConvention;
using __IntPtr = global::System.IntPtr;

namespace QREncode64
{
    /// <summary>Encoding mode.</summary>
    public enum QRencodeMode
    {
        /// <summary>Terminator (NUL character). Internal use only</summary>
        QR_MODE_NUL = -1,
        /// <summary>Numeric mode</summary>
        QR_MODE_NUM = 0,
        /// <summary>Alphabet-numeric mode</summary>
        QR_MODE_AN = 1,
        /// <summary>8-bit data mode</summary>
        QR_MODE_8 = 2,
        /// <summary>Kanji (shift-jis) mode</summary>
        QR_MODE_KANJI = 3,
        /// <summary>Internal use only</summary>
        QR_MODE_STRUCTURE = 4,
        /// <summary>ECI mode</summary>
        QR_MODE_ECI = 5,
        /// <summary>FNC1, first position</summary>
        QR_MODE_FNC1FIRST = 6,
        /// <summary>FNC1, second position</summary>
        QR_MODE_FNC1SECOND = 7
    }

    /// <summary>Level of error correction.</summary>
    public enum QRecLevel
    {
        /// <summary>lowest</summary>
        QR_ECLEVEL_L = 0,
        QR_ECLEVEL_M = 1,
        QR_ECLEVEL_Q = 2,
        /// <summary>highest</summary>
        QR_ECLEVEL_H = 3
    }

    /// <summary>Encoding mode.</summary>
    /// <summary>Level of error correction.</summary>
    /// <summary>
    /// <para>QRcode class.</para>
    /// <para>Symbol data is represented as an array contains width*width uchars.</para>
    /// <para>Each uchar represents a module (dot). If the less significant bit of</para>
    /// <para>the uchar is 1, the corresponding module is black. The other bits are</para>
    /// <para>meaningless for usual applications, but here its specification is described.</para>
    /// </summary>
    /// <summary>
    /// <para>Singly-linked list of QRcode. Used to represent a structured symbols.</para>
    /// <para>A list is terminated with NULL.</para>
    /// </summary>
    public unsafe partial class QRinput
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::QREncode64.QRinput> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::QREncode64.QRinput>();

        protected bool __ownsNativeInstance;

        internal static QRinput __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new QRinput(native.ToPointer(), skipVTables);
        }

        internal static QRinput __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (QRinput)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static QRinput __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new QRinput(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private QRinput(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected QRinput(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    public unsafe partial class QRinputStruct
    {
        public partial struct __Internal
        {
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::QREncode64.QRinputStruct> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::QREncode64.QRinputStruct>();

        protected bool __ownsNativeInstance;

        internal static QRinputStruct __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new QRinputStruct(native.ToPointer(), skipVTables);
        }

        internal static QRinputStruct __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (QRinputStruct)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static QRinputStruct __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new QRinputStruct(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private QRinputStruct(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected QRinputStruct(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }
    }

    /// <summary>
    /// <para>QRcode class.</para>
    /// <para>Symbol data is represented as an array contains width*width uchars.</para>
    /// <para>Each uchar represents a module (dot). If the less significant bit of</para>
    /// <para>the uchar is 1, the corresponding module is black. The other bits are</para>
    /// <para>meaningless for usual applications, but here its specification is described.</para>
    /// </summary>
    public unsafe partial class QRcode : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal int version;
            internal int width;
            internal __IntPtr data;

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\QREncode", EntryPoint = "??0QRcode@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr __0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::QREncode64.QRcode> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::QREncode64.QRcode>();

        protected bool __ownsNativeInstance;

        internal static QRcode __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new QRcode(native.ToPointer(), skipVTables);
        }

        internal static QRcode __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (QRcode)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static QRcode __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new QRcode(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private QRcode(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected QRcode(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public QRcode()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::QREncode64.QRcode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public QRcode(global::QREncode64.QRcode __0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::QREncode64.QRcode.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::QREncode64.QRcode.__Internal*) __Instance) = *((global::QREncode64.QRcode.__Internal*) __0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        /// <summary>version of the symbol</summary>
        public int Version
        {
            get
            {
                return ((__Internal*)__Instance)->version;
            }

            set
            {
                ((__Internal*)__Instance)->version = value;
            }
        }

        /// <summary>width of the symbol</summary>
        public int Width
        {
            get
            {
                return ((__Internal*)__Instance)->width;
            }

            set
            {
                ((__Internal*)__Instance)->width = value;
            }
        }

        /// <summary>symbol data</summary>
        public byte* Data
        {
            get
            {
                return (byte*) ((__Internal*)__Instance)->data;
            }

            set
            {
                ((__Internal*)__Instance)->data = (__IntPtr) value;
            }
        }
    }

    /// <summary>
    /// <para>Singly-linked list of QRcode. Used to represent a structured symbols.</para>
    /// <para>A list is terminated with NULL.</para>
    /// </summary>
    public unsafe partial class QRcodeList : IDisposable
    {
        [StructLayout(LayoutKind.Sequential, Size = 16)]
        public partial struct __Internal
        {
            internal __IntPtr code;
            internal __IntPtr next;

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\QREncode", EntryPoint = "??0_QRcode_List@@QEAA@AEBU0@@Z", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr cctor(__IntPtr __instance, __IntPtr _0);
        }

        public __IntPtr __Instance { get; protected set; }

        internal static readonly global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::QREncode64.QRcodeList> NativeToManagedMap = new global::System.Collections.Concurrent.ConcurrentDictionary<IntPtr, global::QREncode64.QRcodeList>();

        protected bool __ownsNativeInstance;

        internal static QRcodeList __CreateInstance(__IntPtr native, bool skipVTables = false)
        {
            return new QRcodeList(native.ToPointer(), skipVTables);
        }

        internal static QRcodeList __GetOrCreateInstance(__IntPtr native, bool saveInstance = false, bool skipVTables = false)
        {
            if (native == __IntPtr.Zero)
                return null;
            if (NativeToManagedMap.TryGetValue(native, out var managed))
                return (QRcodeList)managed;
            var result = __CreateInstance(native, skipVTables);
            if (saveInstance)
                NativeToManagedMap[native] = result;
            return result;
        }

        internal static QRcodeList __CreateInstance(__Internal native, bool skipVTables = false)
        {
            return new QRcodeList(native, skipVTables);
        }

        private static void* __CopyValue(__Internal native)
        {
            var ret = Marshal.AllocHGlobal(sizeof(__Internal));
            *(__Internal*) ret = native;
            return ret.ToPointer();
        }

        private QRcodeList(__Internal native, bool skipVTables = false)
            : this(__CopyValue(native), skipVTables)
        {
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        protected QRcodeList(void* native, bool skipVTables = false)
        {
            if (native == null)
                return;
            __Instance = new __IntPtr(native);
        }

        public QRcodeList()
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::QREncode64.QRcodeList.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
        }

        public QRcodeList(global::QREncode64.QRcodeList _0)
        {
            __Instance = Marshal.AllocHGlobal(sizeof(global::QREncode64.QRcodeList.__Internal));
            __ownsNativeInstance = true;
            NativeToManagedMap[__Instance] = this;
            *((global::QREncode64.QRcodeList.__Internal*) __Instance) = *((global::QREncode64.QRcodeList.__Internal*) _0.__Instance);
        }

        public void Dispose()
        {
            Dispose(disposing: true, callNativeDtor : __ownsNativeInstance );
        }

        partial void DisposePartial(bool disposing);

        internal protected virtual void Dispose(bool disposing, bool callNativeDtor )
        {
            if (__Instance == IntPtr.Zero)
                return;
            NativeToManagedMap.TryRemove(__Instance, out _);
            DisposePartial(disposing);
            if (__ownsNativeInstance)
                Marshal.FreeHGlobal(__Instance);
            __Instance = IntPtr.Zero;
        }

        public global::QREncode64.QRcode Code
        {
            get
            {
                var __result0 = global::QREncode64.QRcode.__GetOrCreateInstance(((__Internal*)__Instance)->code, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->code = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }

        public global::QREncode64.QRcodeList Next
        {
            get
            {
                var __result0 = global::QREncode64.QRcodeList.__GetOrCreateInstance(((__Internal*)__Instance)->next, false);
                return __result0;
            }

            set
            {
                ((__Internal*)__Instance)->next = value is null ? __IntPtr.Zero : value.__Instance;
            }
        }
    }

    public unsafe partial class qrencode
    {
        public partial struct __Internal
        {
            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_new", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRinput_new();

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_new2", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRinput_new2(int version, global::QREncode64.QRecLevel level);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_newMQR", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRinput_newMQR(int version, global::QREncode64.QRecLevel level);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_append", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int QRinput_append(__IntPtr input, global::QREncode64.QRencodeMode mode, int size, byte* data);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_appendECIheader", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int QRinput_appendECIheader(__IntPtr input, uint ecinum);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_getVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int QRinput_getVersion(__IntPtr input);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_setVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int QRinput_setVersion(__IntPtr input, int version);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_getErrorCorrectionLevel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern global::QREncode64.QRecLevel QRinput_getErrorCorrectionLevel(__IntPtr input);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_setErrorCorrectionLevel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int QRinput_setErrorCorrectionLevel(__IntPtr input, global::QREncode64.QRecLevel level);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_setVersionAndErrorCorrectionLevel", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int QRinput_setVersionAndErrorCorrectionLevel(__IntPtr input, int version, global::QREncode64.QRecLevel level);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void QRinput_free(__IntPtr input);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_check", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int QRinput_check(global::QREncode64.QRencodeMode mode, int size, byte* data);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_Struct_new", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRinputStruct_new();

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_Struct_setParity", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void QRinputStruct_setParity(__IntPtr s, byte parity);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_Struct_appendInput", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int QRinputStruct_appendInput(__IntPtr s, __IntPtr input);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_Struct_free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void QRinputStruct_free(__IntPtr s);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_splitQRinputToStruct", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRinput_splitQRinputToStruct(__IntPtr input);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_Struct_insertStructuredAppendHeaders", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int QRinputStruct_insertStructuredAppendHeaders(__IntPtr s);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_setFNC1First", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int QRinput_setFNC1First(__IntPtr input);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRinput_setFNC1Second", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int QRinput_setFNC1Second(__IntPtr input, byte appid);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_encodeInput", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRcode_encodeInput(__IntPtr input);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_encodeString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRcode_encodeString([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string @string, int version, global::QREncode64.QRecLevel level, global::QREncode64.QRencodeMode hint, int casesensitive);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_encodeString8bit", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRcode_encodeString8bit([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string @string, int version, global::QREncode64.QRecLevel level);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_encodeStringMQR", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRcode_encodeStringMQR([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string @string, int version, global::QREncode64.QRecLevel level, global::QREncode64.QRencodeMode hint, int casesensitive);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_encodeString8bitMQR", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRcode_encodeString8bitMQR([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string @string, int version, global::QREncode64.QRecLevel level);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_encodeData", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRcode_encodeData(int size, byte* data, int version, global::QREncode64.QRecLevel level);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_encodeDataMQR", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRcode_encodeDataMQR(int size, byte* data, int version, global::QREncode64.QRecLevel level);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void QRcode_free(__IntPtr qrcode);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_encodeInputStructured", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRcode_encodeInputStructured(__IntPtr s);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_encodeStringStructured", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRcode_encodeStringStructured([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string @string, int version, global::QREncode64.QRecLevel level, global::QREncode64.QRencodeMode hint, int casesensitive);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_encodeString8bitStructured", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRcode_encodeString8bitStructured([MarshalAs(UnmanagedType.CustomMarshaler, MarshalTypeRef = typeof(CppSharp.Runtime.UTF8Marshaller))] string @string, int version, global::QREncode64.QRecLevel level);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_encodeDataStructured", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern __IntPtr QRcode_encodeDataStructured(int size, byte* data, int version, global::QREncode64.QRecLevel level);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_List_size", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern int QRcodeList_size(__IntPtr qrlist);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_List_free", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void QRcodeList_free(__IntPtr qrlist);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_APIVersion", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void QRcodeAPIVersion(int* major_version, int* minor_version, int* micro_version);

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_APIVersionString", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern sbyte* QRcodeAPIVersionString();

            [SuppressUnmanagedCodeSecurity, DllImport("qrencode\\x64\\qrencode", EntryPoint = "QRcode_clearCache", CallingConvention = __CallingConvention.Cdecl)]
            internal static extern void QRcode_clearCache();
        }

        /// <summary>
        /// <para>Instantiate an input data object. The version is set to 0 (auto-select)</para>
        /// <para>and the error correction level is set to QR_ECLEVEL_L.</para>
        /// </summary>
        /// <returns>
        /// <para>an input object (initialized). On error, NULL is returned and errno</para>
        /// <para>is set to indicate the error.</para>
        /// </returns>
        /// <remarks>ENOMEM unable to allocate memory.</remarks>
        public static global::QREncode64.QRinput QRinput_new()
        {
            var __ret = __Internal.QRinput_new();
            var __result0 = global::QREncode64.QRinput.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Instantiate an input data object.</summary>
        /// <param name="version">version number.</param>
        /// <param name="level">Error correction level.</param>
        /// <returns>
        /// <para>an input object (initialized). On error, NULL is returned and errno</para>
        /// <para>is set to indicate the error.</para>
        /// </returns>
        /// <remarks>
        /// <para>ENOMEM unable to allocate memory for input objects.</para>
        /// <para>EINVAL invalid arguments.</para>
        /// </remarks>
        public static global::QREncode64.QRinput QRinput_new2(int version, global::QREncode64.QRecLevel level)
        {
            var __ret = __Internal.QRinput_new2(version, level);
            var __result0 = global::QREncode64.QRinput.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Instantiate an input data object. Object's Micro QR Code flag is set.</para>
        /// <para>Unlike with full-sized QR Code, version number must be specified (&gt;0).</para>
        /// </summary>
        /// <param name="version">version number (1--4).</param>
        /// <param name="level">Error correction level.</param>
        /// <returns>
        /// <para>an input object (initialized). On error, NULL is returned and errno</para>
        /// <para>is set to indicate the error.</para>
        /// </returns>
        /// <remarks>
        /// <para>ENOMEM unable to allocate memory for input objects.</para>
        /// <para>EINVAL invalid arguments.</para>
        /// </remarks>
        public static global::QREncode64.QRinput QRinput_newMQR(int version, global::QREncode64.QRecLevel level)
        {
            var __ret = __Internal.QRinput_newMQR(version, level);
            var __result0 = global::QREncode64.QRinput.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Append data to an input object.</para>
        /// <para>The data is copied and appended to the input object.</para>
        /// </summary>
        /// <param name="input">input object.</param>
        /// <param name="mode">encoding mode.</param>
        /// <param name="size">size of data (byte).</param>
        /// <param name="data">a pointer to the memory area of the input data.</param>
        /// <remarks>
        /// <para>0 success.</para>
        /// <para>-1 an error occurred and errno is set to indeicate the error.</para>
        /// <para>See Execptions for the details.</para>
        /// <para>ENOMEM unable to allocate memory.</para>
        /// <para>EINVAL input data is invalid.</para>
        /// </remarks>
        public static int QRinput_append(global::QREncode64.QRinput input, global::QREncode64.QRencodeMode mode, int size, byte* data)
        {
            var __arg0 = input is null ? __IntPtr.Zero : input.__Instance;
            var __ret = __Internal.QRinput_append(__arg0, mode, size, data);
            return __ret;
        }

        /// <summary>Append ECI header.</summary>
        /// <param name="input">input object.</param>
        /// <param name="ecinum">ECI indicator number (0 - 999999)</param>
        /// <remarks>
        /// <para>0 success.</para>
        /// <para>-1 an error occurred and errno is set to indeicate the error.</para>
        /// <para>See Execptions for the details.</para>
        /// <para>ENOMEM unable to allocate memory.</para>
        /// <para>EINVAL input data is invalid.</para>
        /// </remarks>
        public static int QRinput_appendECIheader(global::QREncode64.QRinput input, uint ecinum)
        {
            var __arg0 = input is null ? __IntPtr.Zero : input.__Instance;
            var __ret = __Internal.QRinput_appendECIheader(__arg0, ecinum);
            return __ret;
        }

        /// <summary>Get current version.</summary>
        /// <param name="input">input object.</param>
        /// <returns>current version.</returns>
        public static int QRinput_getVersion(global::QREncode64.QRinput input)
        {
            var __arg0 = input is null ? __IntPtr.Zero : input.__Instance;
            var __ret = __Internal.QRinput_getVersion(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set version of the QR code that is to be encoded.</para>
        /// <para>This function cannot be applied to Micro QR Code.</para>
        /// </summary>
        /// <param name="input">input object.</param>
        /// <param name="version">version number (0 = auto)</param>
        /// <remarks>
        /// <para>0 success.</para>
        /// <para>-1 invalid argument.</para>
        /// </remarks>
        public static int QRinput_setVersion(global::QREncode64.QRinput input, int version)
        {
            var __arg0 = input is null ? __IntPtr.Zero : input.__Instance;
            var __ret = __Internal.QRinput_setVersion(__arg0, version);
            return __ret;
        }

        /// <summary>Get current error correction level.</summary>
        /// <param name="input">input object.</param>
        /// <returns>Current error correcntion level.</returns>
        public static global::QREncode64.QRecLevel QRinput_getErrorCorrectionLevel(global::QREncode64.QRinput input)
        {
            var __arg0 = input is null ? __IntPtr.Zero : input.__Instance;
            var __ret = __Internal.QRinput_getErrorCorrectionLevel(__arg0);
            return __ret;
        }

        /// <summary>
        /// <para>Set error correction level of the QR code that is to be encoded.</para>
        /// <para>This function cannot be applied to Micro QR Code.</para>
        /// </summary>
        /// <param name="input">input object.</param>
        /// <param name="level">Error correction level.</param>
        /// <remarks>
        /// <para>0 success.</para>
        /// <para>-1 invalid argument.</para>
        /// </remarks>
        public static int QRinput_setErrorCorrectionLevel(global::QREncode64.QRinput input, global::QREncode64.QRecLevel level)
        {
            var __arg0 = input is null ? __IntPtr.Zero : input.__Instance;
            var __ret = __Internal.QRinput_setErrorCorrectionLevel(__arg0, level);
            return __ret;
        }

        /// <summary>
        /// <para>Set version and error correction level of the QR code at once.</para>
        /// <para>This function is recommened for Micro QR Code.</para>
        /// </summary>
        /// <param name="input">input object.</param>
        /// <param name="version">version number (0 = auto)</param>
        /// <param name="level">Error correction level.</param>
        /// <remarks>
        /// <para>0 success.</para>
        /// <para>-1 invalid argument.</para>
        /// </remarks>
        public static int QRinput_setVersionAndErrorCorrectionLevel(global::QREncode64.QRinput input, int version, global::QREncode64.QRecLevel level)
        {
            var __arg0 = input is null ? __IntPtr.Zero : input.__Instance;
            var __ret = __Internal.QRinput_setVersionAndErrorCorrectionLevel(__arg0, version, level);
            return __ret;
        }

        /// <summary>
        /// <para>Free the input object.</para>
        /// <para>All of data chunks in the input object are freed too.</para>
        /// </summary>
        /// <param name="input">input object.</param>
        public static void QRinput_free(global::QREncode64.QRinput input)
        {
            var __arg0 = input is null ? __IntPtr.Zero : input.__Instance;
            __Internal.QRinput_free(__arg0);
        }

        /// <summary>Validate the input data.</summary>
        /// <param name="mode">encoding mode.</param>
        /// <param name="size">size of data (byte).</param>
        /// <param name="data">a pointer to the memory area of the input data.</param>
        /// <remarks>
        /// <para>0 success.</para>
        /// <para>-1 invalid arguments.</para>
        /// </remarks>
        public static int QRinput_check(global::QREncode64.QRencodeMode mode, int size, byte* data)
        {
            var __ret = __Internal.QRinput_check(mode, size, data);
            return __ret;
        }

        /// <summary>Instantiate a set of input data object.</summary>
        /// <returns>
        /// <para>an instance of QRinput_Struct. On error, NULL is returned and errno</para>
        /// <para>is set to indicate the error.</para>
        /// </returns>
        /// <remarks>ENOMEM unable to allocate memory.</remarks>
        public static global::QREncode64.QRinputStruct QRinputStruct_new()
        {
            var __ret = __Internal.QRinputStruct_new();
            var __result0 = global::QREncode64.QRinputStruct.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Set parity of structured symbols.</summary>
        /// <param name="s">structured input object.</param>
        /// <param name="parity">parity of s.</param>
        public static void QRinputStruct_setParity(global::QREncode64.QRinputStruct s, byte parity)
        {
            var __arg0 = s is null ? __IntPtr.Zero : s.__Instance;
            __Internal.QRinputStruct_setParity(__arg0, parity);
        }

        /// <summary>
        /// <para>Append a QRinput object to the set. QRinput created by QRinput_newMQR()</para>
        /// <para>will be rejected.</para>
        /// </summary>
        /// <param name="s">structured input object.</param>
        /// <param name="input">an input object.</param>
        /// <remarks>
        /// <para>never append the same QRinput object twice or more.</para>
        /// <para>&gt;0 number of input objects in the structure.</para>
        /// <para>-1 an error occurred. See Exceptions for the details.</para>
        /// <para>ENOMEM unable to allocate memory.</para>
        /// <para>EINVAL invalid arguments.</para>
        /// </remarks>
        public static int QRinputStruct_appendInput(global::QREncode64.QRinputStruct s, global::QREncode64.QRinput input)
        {
            var __arg0 = s is null ? __IntPtr.Zero : s.__Instance;
            var __arg1 = input is null ? __IntPtr.Zero : input.__Instance;
            var __ret = __Internal.QRinputStruct_appendInput(__arg0, __arg1);
            return __ret;
        }

        /// <summary>Free all of QRinput in the set.</summary>
        /// <param name="s">a structured input object.</param>
        public static void QRinputStruct_free(global::QREncode64.QRinputStruct s)
        {
            var __arg0 = s is null ? __IntPtr.Zero : s.__Instance;
            __Internal.QRinputStruct_free(__arg0);
        }

        /// <summary>
        /// <para>Split a QRinput to QRinput_Struct. It calculates a parity, set it, then</para>
        /// <para>insert structured-append headers. QRinput created by QRinput_newMQR() will</para>
        /// <para>be rejected.</para>
        /// </summary>
        /// <param name="input">
        /// <para>input object. Version number and error correction level must be</para>
        /// <para>set.</para>
        /// </param>
        /// <returns>
        /// <para>a set of input data. On error, NULL is returned, and errno is set</para>
        /// <para>to indicate the error. See Exceptions for the details.</para>
        /// </returns>
        /// <remarks>
        /// <para>ERANGE input data is too large.</para>
        /// <para>EINVAL invalid input data.</para>
        /// <para>ENOMEM unable to allocate memory.</para>
        /// </remarks>
        public static global::QREncode64.QRinputStruct QRinput_splitQRinputToStruct(global::QREncode64.QRinput input)
        {
            var __arg0 = input is null ? __IntPtr.Zero : input.__Instance;
            var __ret = __Internal.QRinput_splitQRinputToStruct(__arg0);
            var __result0 = global::QREncode64.QRinputStruct.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Insert structured-append headers to the input structure. It calculates</para>
        /// <para>a parity and set it if the parity is not set yet.</para>
        /// </summary>
        /// <param name="s">input structure</param>
        /// <remarks>
        /// <para>0 success.</para>
        /// <para>-1 an error occurred and errno is set to indeicate the error.</para>
        /// <para>See Execptions for the details.</para>
        /// <para>EINVAL invalid input object.</para>
        /// <para>ENOMEM unable to allocate memory.</para>
        /// </remarks>
        public static int QRinputStruct_insertStructuredAppendHeaders(global::QREncode64.QRinputStruct s)
        {
            var __arg0 = s is null ? __IntPtr.Zero : s.__Instance;
            var __ret = __Internal.QRinputStruct_insertStructuredAppendHeaders(__arg0);
            return __ret;
        }

        /// <summary>Set FNC1-1st position flag.</summary>
        public static int QRinput_setFNC1First(global::QREncode64.QRinput input)
        {
            var __arg0 = input is null ? __IntPtr.Zero : input.__Instance;
            var __ret = __Internal.QRinput_setFNC1First(__arg0);
            return __ret;
        }

        /// <summary>Set FNC1-2nd position flag and application identifier.</summary>
        public static int QRinput_setFNC1Second(global::QREncode64.QRinput input, byte appid)
        {
            var __arg0 = input is null ? __IntPtr.Zero : input.__Instance;
            var __ret = __Internal.QRinput_setFNC1Second(__arg0, appid);
            return __ret;
        }

        /// <summary>Create a symbol from the input data.</summary>
        /// <param name="input">input data.</param>
        /// <returns>
        /// <para>an instance of QRcode class. The version of the result QRcode may</para>
        /// <para>be larger than the designated version. On error, NULL is returned,</para>
        /// <para>and errno is set to indicate the error. See Exceptions for the</para>
        /// <para>details.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function is THREAD UNSAFE when pthread is disabled.</para>
        /// <para>EINVAL invalid input object.</para>
        /// <para>ENOMEM unable to allocate memory for input objects.</para>
        /// </remarks>
        public static global::QREncode64.QRcode QRcode_encodeInput(global::QREncode64.QRinput input)
        {
            var __arg0 = input is null ? __IntPtr.Zero : input.__Instance;
            var __ret = __Internal.QRcode_encodeInput(__arg0);
            var __result0 = global::QREncode64.QRcode.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Create a symbol from the string. The library automatically parses the input</para>
        /// <para>string and encodes in a QR Code symbol.</para>
        /// </summary>
        /// <param name="string">input string. It must be NUL terminated.</param>
        /// <param name="version">
        /// <para>version of the symbol. If 0, the library chooses the minimum</para>
        /// <para>version for the given input data.</para>
        /// </param>
        /// <param name="level">error correction level.</param>
        /// <param name="hint">
        /// <para>tell the library how Japanese Kanji characters should be</para>
        /// <para>encoded. If QR_MODE_KANJI is given, the library assumes that the</para>
        /// <para>given string contains Shift-JIS characters and encodes them in</para>
        /// <para>Kanji-mode. If QR_MODE_8 is given, all of non-alphanumerical</para>
        /// <para>characters will be encoded as is. If you want to embed UTF-8</para>
        /// <para>string, choose this. Other mode will cause EINVAL error.</para>
        /// </param>
        /// <param name="casesensitive">case-sensitive(1) or not(0).</param>
        /// <returns>
        /// <para>an instance of QRcode class. The version of the result QRcode may</para>
        /// <para>be larger than the designated version. On error, NULL is returned,</para>
        /// <para>and errno is set to indicate the error. See Exceptions for the</para>
        /// <para>details.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function is THREAD UNSAFE when pthread is disabled.</para>
        /// <para>EINVAL invalid input object.</para>
        /// <para>ENOMEM unable to allocate memory for input objects.</para>
        /// <para>ERANGE input data is too large.</para>
        /// </remarks>
        public static global::QREncode64.QRcode QRcode_encodeString(string @string, int version, global::QREncode64.QRecLevel level, global::QREncode64.QRencodeMode hint, int casesensitive)
        {
            var __ret = __Internal.QRcode_encodeString(@string, version, level, hint, casesensitive);
            var __result0 = global::QREncode64.QRcode.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Same to QRcode_encodeString(), but encode whole data in 8-bit mode.</summary>
        /// <remarks>This function is THREAD UNSAFE when pthread is disabled.</remarks>
        public static global::QREncode64.QRcode QRcode_encodeString8bit(string @string, int version, global::QREncode64.QRecLevel level)
        {
            var __ret = __Internal.QRcode_encodeString8bit(@string, version, level);
            var __result0 = global::QREncode64.QRcode.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Micro QR Code version of QRcode_encodeString().</summary>
        /// <remarks>This function is THREAD UNSAFE when pthread is disabled.</remarks>
        public static global::QREncode64.QRcode QRcode_encodeStringMQR(string @string, int version, global::QREncode64.QRecLevel level, global::QREncode64.QRencodeMode hint, int casesensitive)
        {
            var __ret = __Internal.QRcode_encodeStringMQR(@string, version, level, hint, casesensitive);
            var __result0 = global::QREncode64.QRcode.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Micro QR Code version of QRcode_encodeString8bit().</summary>
        /// <remarks>This function is THREAD UNSAFE when pthread is disabled.</remarks>
        public static global::QREncode64.QRcode QRcode_encodeString8bitMQR(string @string, int version, global::QREncode64.QRecLevel level)
        {
            var __ret = __Internal.QRcode_encodeString8bitMQR(@string, version, level);
            var __result0 = global::QREncode64.QRcode.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Encode byte stream (may include '\0') in 8-bit mode.</summary>
        /// <param name="size">size of the input data.</param>
        /// <param name="data">input data.</param>
        /// <param name="version">
        /// <para>version of the symbol. If 0, the library chooses the minimum</para>
        /// <para>version for the given input data.</para>
        /// </param>
        /// <param name="level">error correction level.</param>
        /// <remarks>
        /// <para>This function is THREAD UNSAFE when pthread is disabled.</para>
        /// <para>EINVAL invalid input object.</para>
        /// <para>ENOMEM unable to allocate memory for input objects.</para>
        /// <para>ERANGE input data is too large.</para>
        /// </remarks>
        public static global::QREncode64.QRcode QRcode_encodeData(int size, byte* data, int version, global::QREncode64.QRecLevel level)
        {
            var __ret = __Internal.QRcode_encodeData(size, data, version, level);
            var __result0 = global::QREncode64.QRcode.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Micro QR Code version of QRcode_encodeData().</summary>
        /// <remarks>This function is THREAD UNSAFE when pthread is disabled.</remarks>
        public static global::QREncode64.QRcode QRcode_encodeDataMQR(int size, byte* data, int version, global::QREncode64.QRecLevel level)
        {
            var __ret = __Internal.QRcode_encodeDataMQR(size, data, version, level);
            var __result0 = global::QREncode64.QRcode.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Free the instance of QRcode class.</summary>
        /// <param name="qrcode">an instance of QRcode class.</param>
        public static void QRcode_free(global::QREncode64.QRcode qrcode)
        {
            var __arg0 = qrcode is null ? __IntPtr.Zero : qrcode.__Instance;
            __Internal.QRcode_free(__arg0);
        }

        /// <summary>Create structured symbols from the input data.</summary>
        /// <param name="s">input data, structured.</param>
        /// <returns>a singly-linked list of QRcode.</returns>
        /// <remarks>This function is THREAD UNSAFE when pthread is disabled.</remarks>
        public static global::QREncode64.QRcodeList QRcode_encodeInputStructured(global::QREncode64.QRinputStruct s)
        {
            var __arg0 = s is null ? __IntPtr.Zero : s.__Instance;
            var __ret = __Internal.QRcode_encodeInputStructured(__arg0);
            var __result0 = global::QREncode64.QRcodeList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Create structured symbols from the string. The library automatically parses</para>
        /// <para>the input string and encodes in a QR Code symbol.</para>
        /// </summary>
        /// <param name="string">input string. It must be NUL terminated.</param>
        /// <param name="version">version of the symbol.</param>
        /// <param name="level">error correction level.</param>
        /// <param name="hint">
        /// <para>tell the library how Japanese Kanji characters should be</para>
        /// <para>encoded. If QR_MODE_KANJI is given, the library assumes that the</para>
        /// <para>given string contains Shift-JIS characters and encodes them in</para>
        /// <para>Kanji-mode. If QR_MODE_8 is given, all of non-alphanumerical</para>
        /// <para>characters will be encoded as is. If you want to embed UTF-8</para>
        /// <para>string, choose this. Other mode will cause EINVAL error.</para>
        /// </param>
        /// <param name="casesensitive">case-sensitive(1) or not(0).</param>
        /// <returns>
        /// <para>a singly-linked list of QRcode. On error, NULL is returned, and</para>
        /// <para>errno is set to indicate the error. See Exceptions for the details.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function is THREAD UNSAFE when pthread is disabled.</para>
        /// <para>EINVAL invalid input object.</para>
        /// <para>ENOMEM unable to allocate memory for input objects.</para>
        /// </remarks>
        public static global::QREncode64.QRcodeList QRcode_encodeStringStructured(string @string, int version, global::QREncode64.QRecLevel level, global::QREncode64.QRencodeMode hint, int casesensitive)
        {
            var __ret = __Internal.QRcode_encodeStringStructured(@string, version, level, hint, casesensitive);
            var __result0 = global::QREncode64.QRcodeList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Same to QRcode_encodeStringStructured(), but encode whole data in 8-bit mode.</summary>
        /// <remarks>This function is THREAD UNSAFE when pthread is disabled.</remarks>
        public static global::QREncode64.QRcodeList QRcode_encodeString8bitStructured(string @string, int version, global::QREncode64.QRecLevel level)
        {
            var __ret = __Internal.QRcode_encodeString8bitStructured(@string, version, level);
            var __result0 = global::QREncode64.QRcodeList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>
        /// <para>Create structured symbols from byte stream (may include '\0'). Wholde data</para>
        /// <para>are encoded in 8-bit mode.</para>
        /// </summary>
        /// <param name="size">size of the input data.</param>
        /// <param name="data">input dat.</param>
        /// <param name="version">version of the symbol.</param>
        /// <param name="level">error correction level.</param>
        /// <returns>
        /// <para>a singly-linked list of QRcode. On error, NULL is returned, and</para>
        /// <para>errno is set to indicate the error. See Exceptions for the details.</para>
        /// </returns>
        /// <remarks>
        /// <para>This function is THREAD UNSAFE when pthread is disabled.</para>
        /// <para>EINVAL invalid input object.</para>
        /// <para>ENOMEM unable to allocate memory for input objects.</para>
        /// </remarks>
        public static global::QREncode64.QRcodeList QRcode_encodeDataStructured(int size, byte* data, int version, global::QREncode64.QRecLevel level)
        {
            var __ret = __Internal.QRcode_encodeDataStructured(size, data, version, level);
            var __result0 = global::QREncode64.QRcodeList.__GetOrCreateInstance(__ret, false);
            return __result0;
        }

        /// <summary>Return the number of symbols included in a QRcode_List.</summary>
        /// <param name="qrlist">a head entry of a QRcode_List.</param>
        /// <returns>number of symbols in the list.</returns>
        public static int QRcodeList_size(global::QREncode64.QRcodeList qrlist)
        {
            var __arg0 = qrlist is null ? __IntPtr.Zero : qrlist.__Instance;
            var __ret = __Internal.QRcodeList_size(__arg0);
            return __ret;
        }

        /// <summary>Free the QRcode_List.</summary>
        /// <param name="qrlist">a head entry of a QRcode_List.</param>
        public static void QRcodeList_free(global::QREncode64.QRcodeList qrlist)
        {
            var __arg0 = qrlist is null ? __IntPtr.Zero : qrlist.__Instance;
            __Internal.QRcodeList_free(__arg0);
        }

        /// <summary>Return a string that identifies the library version.</summary>
        /// <param name="major_version">major version number</param>
        /// <param name="minor_version">minor version number</param>
        /// <param name="micro_version">micro version number</param>
        public static void QRcodeAPIVersion(ref int major_version, ref int minor_version, ref int micro_version)
        {
            fixed (int* __major_version0 = &major_version)
            {
                var __arg0 = __major_version0;
                fixed (int* __minor_version1 = &minor_version)
                {
                    var __arg1 = __minor_version1;
                    fixed (int* __micro_version2 = &micro_version)
                    {
                        var __arg2 = __micro_version2;
                        __Internal.QRcodeAPIVersion(__arg0, __arg1, __arg2);
                    }
                }
            }
        }

        /// <summary>Return a string that identifies the library version.</summary>
        /// <returns>
        /// <para>a string identifies the library version. The string is held by the</para>
        /// <para>library. Do NOT free it.</para>
        /// </returns>
        public static sbyte* QRcodeAPIVersionString()
        {
            var __ret = __Internal.QRcodeAPIVersionString();
            return __ret;
        }

        public static void QRcode_clearCache()
        {
            __Internal.QRcode_clearCache();
        }
    }
}
